#### 그리디 알고리즘 문제

문제 설명 : 한 마을에 모험가가 N명 있다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어진다.
공포도 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있다.

최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금하다. N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하라

예를 들어 N = 5이고, 각 모험가의 공포도가 다음과 같다고 가정하자.
```
2 3 1 2 2
```
이 경우 그룹 1에 공포도가 1,2,3인 모험가를 한 명씩 넣고, 그룹 2에 공포도가 2인 남은 두 명을 넣게 되면 총 2개의 그룹을 만들 수 있다.

또한 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없다.

입력 조건 
- 첫째 줄에 모험가의 수 N이 주어진다.(1<= N <= 100,000)
- 둘째 줄에 각 모험가의 공포도 값을 N이하의 자연수로 주어지며, 각 자연수는 공백으로 구분

출력 조건
- 여행을 떠날 수 있는 그룹 수의 최댓값을 출력한다.

_ _ _

이 문제를 정리하는 이유는 다음과 같다.
- 그리디 알고리즘이다.
- 문제난이도는 하 인데 제대로 풀지 못했다.
- 정렬 방법을 이용해야 하는데 정렬하지 않고 풀이하려고 했다.

이제 내가 정리한 소스코드를 보자.
```
n = int(input())
data = list(map(int,input().split()))
result = 0
num = 0

for i in range(0, len(data)- 1) :
    if data[i] == 1 :
        result += 1
    else :
        for j in range(i+1, len(data)- 1):
            if data[i] == data[j] :
                num += 1
        result += (num//data[i])
        num = 0

print(result)

```

이게 내가 맞았다고 생각했던 소스코드이다.
이렇게 해도 정답이 나오긴 하나, 정확한 답인지는 확실하지 않다.

이 문제에서 n은 쓰지 않아도 답이 나오고..
for문도 두번써서 시간복잡도도 좋지 않다. 나중에 시간복잡도 구하는걸 제대로 알게 된다면
시간복잡도도 구해보자.


이 문제의 해설을 확인해보자.

<문제 해결 아이디어>

오름차순 정렬 이후에 공포도가 가장 낮은 모험가부터 하나씩 확인합니다.

앞에서부터 공포도를 하나씩 확인하며 '현재 그룹에 포함된 모험가의 수'가 '현재 확인하고 있는 공포도' 보다 크거나 같다면 이를 그룹으로 설정하면 됩니다.

이러한 방법을 이용하면 공포도가 오름차순으로 정렬되어 있다는 점에서, 항상 최소한의 모험가의 수만 포함하여 그룹을 결성하게 됩니다.

```
n = int(input())
data = list(map(int, input().split()))
data.sort()

result = 0 # 총 그룹의 수
count = 0 # 현재 그룹에 포함된 모험가의 수

for i in data: # 공포도를 낮은 것부터 하나씩 확인하며
    count += 1 # 현재 그룹에 해당 모험가를 포함시키기
    if count >= i : #현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면, 그룹 결성
        result += 1
        count = 0 # 현재 그룹에 포함된 모험가의 수 초기화

print(result) # 총 그룹의 수 출력
```
이것이 코딩 테스트다 with 파이썬 의 저자 나동빈이라는 분은 이렇게 풀이를 하였다.

이렇게 풀이를 하면 for문과 if문을 한번씩만 사용해도 되기 때문에 시간복잡도가 줄어들게 된다.
그리고 sort()라는 정렬을 사용하여 문제를 조금더 간편하게 풀이를 하였다.

이렇게 문제를 풀이하면 된다는 점을 인지하고 넘어가자.

_ _ _

다음 문제로 큰 수의 법칙이다.

문제
'큰 수의 법칙'은 일반적으로 통계 분야에서 다루어지는 내용이지만 저자는 본인만의 방식으로 다르게 사용하고 있다.
다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.
단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.

예를들어 2,4,5,4,6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자.
이 경우 특정한 인덱스의 수가 연속해서 3번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이 된다.
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
예를 들어 순서대로 3,4,3,4,3 으로 이루어진 배열이 있을때 M이 7이고, K가 2라고 가정하자.
이 경우 두 번째 원소에 해당하는 4와 네 번째 해당하는 4를 번갈아 2번씩 더하는 것이 가능하다.
따라서 4 + 4 + 4 + 4 + 4 + 4 + 4 인 28이 도출된다.

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 저자의 큰 수의 법칙에 따른 결과를 출력해라.

입력 조건 
- 첫째 줄에 N(2<=N<=1,000),M(1<=M<=1,000),K(1<=K,10,000)의 자연수가 주어지며 각 자연수는 공백으로 구분한다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000 이하의 수로 주어진다
- 입력으로 주어지는 K는 항상 M보다 작거나 같다.

출력 조건
- 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

입력 예시
```
5 8 3
2 4 5 4 6
```
출력 예시
```
46
```

나만의 문제 풀이는 다음과 같다.
```
n, m, k = map(int,input().split())
data = list(map(int,input().split()))
data.sort()

result = 0
num = 1

for i in range(m):
    if num <= k :
        result += data[-1]
        num += 1
    else :
        result += data[-2]
        num = 1

print(result)
```

해설 : 우선 n, m, k에 각각 숫자를 넣어주고 
각각의 수를 list로 받아준다.
그 후  sort() 정렬에 의하여 제일 큰 수가 data[-1]이 되고 그 다음 큰 수가 data[-2]가 된다.
물론 data[-2]와 data[-1]이 같을수도 있으나, 그건 문제에 의해 상관이 없다.

이후 for문으로 m번만큼 돌리고 result값에 제일 큰 수를 k번 만큼 더할 수 있도록
num이라는 변수보다 k값이 크거나 같다면 result값에 큰 수를 계속 더하고
만약 아니라면 제일 큰 수보다 작은 수를 더한 후 num 값을 1로 초기화한다.

이렇게 풀이를 하게 되면 정답이 나오게 된다.

내가 문제풀이한 방식은 위와 같은데, 책에 나와있는 풀이법을 보면서 익혀보자
```
# n, m, k를 공백으로 구분하여 입력받기
n, m, k = map(int, input().split())
#n개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))

data.sort() # 입력받은 수들 정렬하기
first = data[n - 1] # 가장 큰 수
second = data[n - 2] # 두 번째로 큰 수

result = 0

while True :
    for i in range(k): # 가장 큰 수를 k번 더하기
        if m == 0: # m이 0이라면 반복문 탈출
            break
        result += first
        m-=1 # 더할 때마다 1씩 빼기
    if m == 0: # m이 0이라면 반복문 탈출
        break
    result += second # 두 번째로 큰 수를 한번 더하기
    m -= 1 # 더할 때마다 1씩 빼기

print(result) # 최종 답안 출력
```

이게 책에 나와있는 답안이다.
샾으로 해석한 부분을 빼더라도 내가 풀이한 해석보다 길어보인다.
특히, 가장 큰 수랑 두번째로 큰 수를 굳이 저렇게 해야하나 싶다.
(그냥 -1이랑 -2로 해도 가장 큰 수랑 그 다음수가 되지 않나...?)

**++책에는 다른 풀이방법도 나와있다.++**
이 문제는 M이 10,000이하이기 때문에 이렇게 풀어도 되지만
M의 크기가 무한정 커진다면, 시간 초과 판정을 받을 것이다.
간단한 수학적 아이디어를 이용해 더 효율적으로 문제를 풀이해본다.

예를 들어 N이 5이고 입력값이 다음과 같이 주어졌다고 가정하자.
2, 4, 5, 4, 6

이때 가장 큰 수와 두 번째로 큰 수를 선택하면 6과 5이다.
이때 M이 8이고 K가 3이라면 다음과 같이 더했을때 합을 최대로 할 수 있다.
6+6+6+5 / 6+6+6+5

이 문제를 풀려면 가장 먼저 반복되는 수열에 대해서 파악해야 한다.
가장 큰 수와 두 번째로 큰 수가 더해질 때는 특정한 수열 형태로 일정하게 반복해서 더해지는 특징이 있다.
위의 예시에서는 수열 {6,6,6,5}가 반복된다.
그렇다면 반복되는 수열의 길이는 어떻게 될까? 바로 (K+1)로 위의 예시에서는 4가 된다.
따라서 M을 (K+1)로 나눈 몫이 수열이 반복되는 횟수이다.
다시 여기에 K를 곱해주면 가장 큰 수가 등장하는 횟수가 된다.

이때 M이 (K+1)로 나누어지지 않는 경우도 고려해야 한다.
그럴 때는 M을 (K+1)로 나눈 나머지 만큼 가장 큰 수가 추가로 더해지므로 이를 고려해주자.
즉, '가장 큰 수가 더해지는 횟수'는 다음과 같다
int(M /(K+1) * K + M % (K + 1)) 

결과적으로 위의 식을 이용하여 가장 큰 수가 더해지는 횟수를 구한 다음,
이를 이용해 두 번째로 큰 수가 더해지는 횟수까지 구할수가 있다.

```
# n, m, k를 공백으로 구분하여 입력받기
n, m, k = map(int, input().split())
#n개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))

data.sort() # 입력받은 수들 정렬하기
first = data[n - 1] # 가장 큰 수
second = data[n - 2] # 두 번째로 큰 수

count = int(m / (k+1)) * k
count += m % (k + 1)

result = 0
result += (count) * first
result += (m - count) * second

print(result)
```

이걸 보고 충격먹었다.
수학적인 지식까지 있어야 이 문제를 시간복잡도를 생각하여 간결하게 풀이할 수 있다.
(수학 공부를 열심히 해야하나...)

쨋든 두 번째 소스코드는 배울점이 매우 많은 코드이다.
따라서 두 번째 소스코드를 잘 배워서 다음번에 써먹도록 하자.




